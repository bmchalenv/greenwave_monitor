# SPDX-FileCopyrightText: NVIDIA CORPORATION & AFFILIATES
# Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0

name: Generate Debian Packages

on:
  pull_request:
    branches: [ main ]
    types: [ opened, synchronize, reopened, ready_for_review ]
  workflow_dispatch:  # Manual trigger
    inputs:
      ros_distros:
        description: 'ROS distributions to build (comma-separated: humble,iron,jazzy,kilted,rolling)'
        required: false
  schedule:
    - cron: '0 2 * * *'  # Nightly at 2 AM UTC

env:
  ROS_LOCALHOST_ONLY: 1
  ROS_AUTOMATIC_DISCOVERY_RANGE: LOCALHOST

jobs:
  determine-distros:
    runs-on: ubuntu-latest
    outputs:
      distros: ${{ steps.set-distros.outputs.distros }}
    steps:
    - name: Determine ROS distributions to build
      id: set-distros
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          # Manual trigger - use input or default
          DISTROS="${{ github.event.inputs.ros_distros || 'humble,iron,jazzy,kilted,rolling' }}"
        else
          # Always build all distributions
          DISTROS="humble,iron,jazzy,kilted,rolling"
        fi
        echo "Building for distributions: $DISTROS"
        # Convert to JSON array for matrix
        JSON_ARRAY=$(echo "$DISTROS" | jq -R -c 'split(",") | map(select(length > 0))')
        echo "distros=$JSON_ARRAY" >> $GITHUB_OUTPUT

  generate-debian:
    name: Generate Debian packages for ROS2 ${{ matrix.ros_distro }}
    runs-on: ubuntu-latest
    needs: [determine-distros]
    container:
      image: ubuntu:${{ matrix.ubuntu_distro }}

    strategy:
      fail-fast: false
      matrix:
        ros_distro: ${{ fromJson(needs.determine-distros.outputs.distros) }}
        include:
          - ros_distro: humble
            ubuntu_distro: jammy
          - ros_distro: iron
            ubuntu_distro: jammy
          - ros_distro: jazzy
            ubuntu_distro: noble
          - ros_distro: kilted
            ubuntu_distro: noble
          - ros_distro: rolling
            ubuntu_distro: noble

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Build Debian packages
      run: |
        chmod +x scripts/build_debian_packages.sh
        ./scripts/build_debian_packages.sh ${{ matrix.ros_distro }} ${{ matrix.ubuntu_distro }}
      shell: bash
      env:
        DEBIAN_FRONTEND: noninteractive

    - name: Upload Debian packages
      uses: actions/upload-artifact@v4
      with:
        name: debian-packages-${{ matrix.ros_distro }}
        path: debian_packages/${{ matrix.ros_distro }}/
        retention-days: 30

  smoke-test:
    name: Smoke test ROS2 ${{ matrix.ros_distro }}
    runs-on: ubuntu-latest
    needs: [determine-distros, generate-debian]
    container:
      image: ubuntu:${{ matrix.ubuntu_distro }}

    strategy:
      fail-fast: false
      matrix:
        ros_distro: ${{ fromJson(needs.determine-distros.outputs.distros) }}
        include:
          - ros_distro: humble
            ubuntu_distro: jammy
          - ros_distro: iron
            ubuntu_distro: jammy
          - ros_distro: jazzy
            ubuntu_distro: noble
          - ros_distro: kilted
            ubuntu_distro: noble
          - ros_distro: rolling
            ubuntu_distro: noble

    steps:
    - name: Setup ROS repository and install base ROS
      run: |
        export DEBIAN_FRONTEND=noninteractive
        export TZ=Etc/UTC
        ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone

        apt-get update -qq
        apt-get install -y curl gnupg lsb-release
        curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(lsb_release -cs) main" > /etc/apt/sources.list.d/ros2.list
        apt-get update -qq

        # Install minimal ROS to get /opt/ros and basic infrastructure
        apt-get install -y ros-${{ matrix.ros_distro }}-ros-core
      shell: bash
      env:
        DEBIAN_FRONTEND: noninteractive

    - name: Download Debian packages
      uses: actions/download-artifact@v4
      with:
        name: debian-packages-${{ matrix.ros_distro }}
        path: debian_packages/${{ matrix.ros_distro }}/

    - name: Install and test packages
      run: |
        set -eo pipefail
        echo "Smoke testing install on ROS2 ${{ matrix.ros_distro }}"
        ls -la debian_packages/${{ matrix.ros_distro }}/

        # Install the debian packages on top of ros-core
        apt-get install -y ./debian_packages/${{ matrix.ros_distro }}/ros-${{ matrix.ros_distro }}-greenwave-monitor_*.deb

        # Verify packages are installed
        dpkg -s ros-${{ matrix.ros_distro }}-greenwave-monitor
      shell: bash
      env:
        DEBIAN_FRONTEND: noninteractive

    - name: Test ncurses_dashboard execution (no extra dependencies)
      run: |
        source /opt/ros/${{ matrix.ros_distro }}/setup.bash

        # Test ncurses frontend BEFORE installing any pip dependencies
        # This verifies it works with only stdlib (curses) from the debian package
        echo "Testing ncurses_dashboard (no extra dependencies required)..."

        # Start monitor node in background for ncurses to connect to
        ros2 run greenwave_monitor greenwave_monitor > /dev/null 2>&1 & echo $! > /tmp/gwm_ncurses.pid
        sleep 3

        # Run ncurses frontend with simulated terminal and quit command
        # Exit code 0 means clean exit (not 11 for SIGSEGV or 134 for SIGABRT)
        # Set TERM=linux to provide basic terminal capabilities for curses
        set +e
        TERM=linux timeout 10s script -qfec 'ros2 run greenwave_monitor ncurses_dashboard' /dev/null <<< $'q'
        EXIT_CODE=$?
        set -e

        if [ $EXIT_CODE -eq 0 ]; then
          echo "✓ ncurses_dashboard exited cleanly"
        elif [ $EXIT_CODE -eq 124 ]; then
          echo "✗ ncurses_dashboard timed out"
          kill -9 "$(cat /tmp/gwm_ncurses.pid)" 2>/dev/null || true
          exit 1
        elif [ $EXIT_CODE -eq 11 ] || [ $EXIT_CODE -eq 139 ]; then
          echo "✗ ncurses_dashboard crashed with SIGSEGV (code: $EXIT_CODE)"
          kill -9 "$(cat /tmp/gwm_ncurses.pid)" 2>/dev/null || true
          exit 1
        elif [ $EXIT_CODE -eq 134 ]; then
          echo "✗ ncurses_dashboard crashed with SIGABRT/core dump (code: $EXIT_CODE)"
          kill -9 "$(cat /tmp/gwm_ncurses.pid)" 2>/dev/null || true
          exit 1
        else
          echo "✓ ncurses_dashboard exited with code: $EXIT_CODE (acceptable)"
        fi

        # Cleanup
        kill -INT "$(cat /tmp/gwm_ncurses.pid)" 2>/dev/null || true
        sleep 1
        kill -9 "$(cat /tmp/gwm_ncurses.pid)" 2>/dev/null || true
      shell: bash

    - name: Clone r2s_gw repository for integration testing
      run: |
        # Install git if not available
        apt-get update -qq
        apt-get install -y git

        # Try to clone the matching branch, fallback to main if it doesn't exist
        # Use head_ref for PRs (actual branch name), ref_name for pushes
        BRANCH_NAME="${{ github.head_ref || github.ref_name }}"
        if git ls-remote --exit-code --heads https://github.com/NVIDIA-ISAAC-ROS/r2s_gw.git "$BRANCH_NAME" > /dev/null 2>&1; then
          echo "Cloning r2s_gw branch: $BRANCH_NAME"
          git clone --branch "$BRANCH_NAME" --depth 1 https://github.com/NVIDIA-ISAAC-ROS/r2s_gw.git
        else
          echo "Branch $BRANCH_NAME not found in r2s_gw, falling back to main"
          git clone --branch main --depth 1 https://github.com/NVIDIA-ISAAC-ROS/r2s_gw.git
        fi
      shell: bash

    - name: Install Python dependencies for r2s_gw
      run: |
        # Install pip if not available
        apt-get install -y python3-pip python3-colcon-common-extensions || true

        # Install Python dependencies
        if [[ "${{ matrix.ros_distro }}" == "jazzy" || \
              "${{ matrix.ros_distro }}" == "kilted" || \
              "${{ matrix.ros_distro }}" == "rolling" ]]; then
          pip3 install --break-system-packages --ignore-installed pygments textual
        else
          pip3 install --ignore-installed pygments textual
        fi
      shell: bash

    - name: Build r2s_gw with colcon
      run: |
        source /opt/ros/${{ matrix.ros_distro }}/setup.bash
        # Build r2s_gw to register it as a ROS package
        colcon build --packages-select r2s_gw --base-paths .
      shell: bash

    - name: Test r2s_gw_dashboard execution
      run: |
        source /opt/ros/${{ matrix.ros_distro }}/setup.bash
        source install/local_setup.bash

        echo "Testing r2s_gw_dashboard with debian-installed greenwave_monitor..."

        # Test r2s_gw dashboard with proper terminal
        # The dashboard script automatically starts the monitor node
        set +e
        TERM=linux timeout 10s script -qfec 'ros2 run r2s_gw r2s_gw_dashboard' /dev/null <<< $'q'
        EXIT_CODE=$?
        set -e

        if [ $EXIT_CODE -eq 0 ]; then
          echo "✓ r2s_gw_dashboard exited cleanly"
        elif [ $EXIT_CODE -eq 124 ]; then
          echo "✗ r2s_gw_dashboard timed out"
          exit 1
        else
          echo "✗ r2s_gw_dashboard exited with unexpected code: $EXIT_CODE"
          exit 1
        fi
      shell: bash

    - name: Test greenwave_monitor execution
      run: |
        source /opt/ros/${{ matrix.ros_distro }}/setup.bash

        # Start ROS 2 daemon to help with DDS discovery
        ros2 daemon start || true
        sleep 2

        # Start node in background
        ros2 run greenwave_monitor greenwave_monitor > /dev/null 2>&1 & echo $! > /tmp/gwm.pid
        echo "Started greenwave_monitor with PID: $(cat /tmp/gwm.pid)"

        # Wait longer for DDS discovery in CI environment
        sleep 10

        # Check if process is still running
        if ps -p $(cat /tmp/gwm.pid) > /dev/null; then
          echo "✓ Process is running"
        else
          echo "✗ Process died!"
          exit 1
        fi

        # List nodes with retry logic
        echo "Running ros2 node list..."
        for i in {1..3}; do
          ros2 node list | tee /tmp/nodes.txt
          if [ -s /tmp/nodes.txt ]; then
            break
          fi
          echo "Retry $i: Node list empty, waiting..."
          sleep 3
        done

        echo "Nodes found:"
        cat /tmp/nodes.txt

        # Check if our node is in the list
        if grep -q greenwave_monitor /tmp/nodes.txt; then
          echo "✓ Node found in list"
        else
          echo "✗ Node NOT found in list (DDS discovery issue in CI)"
          echo "Process is running, so package installation is OK - considering test passed"
        fi

        # Cleanup
        kill -INT "$(cat /tmp/gwm.pid)" || true
        sleep 2
        kill -9 $(cat /tmp/gwm.pid) 2>/dev/null || true
        ros2 daemon stop || true
      shell: bash